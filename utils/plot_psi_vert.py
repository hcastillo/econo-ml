#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Plots:
 - Generate a table of axis_x x axis_y plots:
      items of statistics of gdts generated by interbank.py
      rows are different values of psi (inside each plot is p)
      cols are different experiments conducted


@author: hector@bith.net
@date:   10/2025
"""
import argparse
import matplotlib.pyplot as plt
import numpy as np
import os
import scipy.stats
from interbank import Statistics
import sys

class PlotPsi:
    working_dir = '/experiments/20251015.psi_0a1_raiz_cuadrada'
    output = 'p_psi_vert'

    axis_x = ['equity', 'bankruptcies', 'interest_rate', 'bad_debt','asset_i','asset_j', 'prob_bankruptcy']
    with_log = ['equity']

    titles_x = ['$log(E)$', 'bankruptcy', '$i_r$', '$B$','$asset_i$','$asset_j$','$prob_{bank}$']
    axis_y = ['1_psi0', '1_psi025', '1_psi05', '1_psi075', '1_psi1']  #, '3_psiendog']
    titles_y = ['psi=0', 'psi=0.25', 'psi=0.5', 'psi=0.75', 'psi=0.99']  #,'psi endogenous' ]
    title_of_output = 'comparing p/psi'

    correlations = [['interest_rate','bad_debt'],['interest_rate','bankruptcies'],['interest_rate','equity'],['bad_debt','equity']]
    # renames can contain key values as { 'dir1':'d' } so resultant variable will be
    # bankruptcies_d instead of bankruptcies_dir1:
    RENAMES = {'-not_exists-': '_n'}

    # x inside each individual plot (in this case, values of p):
    # x = list(np.linspace(0.0001, 0.2, num=5))
    x = [0.0001, 0.05, 0.07,
                    0.08,
               0.09, 0.1, 0.15, 0.2, 1]
    #x = [0.0001, 0.05, 0.1, 0.15, 0.2]

    def get_cross_correlation_result1(self, data,column_a, column_b, t):
        result = 'correl not valid            '
        try:
            if t==0:
                correlation_value = scipy.stats.pearsonr(data[column_a], data[column_b])
            else:
                correlation_value = scipy.stats.pearsonr(data[column_a][t:], data[column_b][:-t])
        except ValueError:
            correlation_value = None
        if correlation_value:
            status = '  '
            if correlation_value.pvalue < 0.05:
                status = '**'
            elif correlation_value.pvalue < 0.10:
                status = '* '
            result = (f'correl t={t} {column_a}/{column_b} {correlation_value.statistic:4.2} '
                      f'p_value={correlation_value.pvalue:4.2} {status}')
        return result


    def format_cross_correlation_result(self, correlation_value):
       if correlation_value:
           status = '  '
           if correlation_value.pvalue < 0.05:
               status = '**'
           elif correlation_value.pvalue < 0.10:
               status = '* '
           return '%4.2f p=%4.2f %s' % (correlation_value.statistic,correlation_value.pvalue,status)
       else:
           return '      '

    def get_cross_correlation_result(self, data,column_a, column_b, t):
        try:
            if t==0:
                return scipy.stats.pearsonr(data[column_a], data[column_b])
            else:
                return scipy.stats.pearsonr(data[column_a][t:], data[column_b][:-t])
        except ValueError:
            return None

    def determine_cross_correlation1(self, experiment_dir, file, column_a, column_b):
        file_full_path = self.working_dir + f'/{experiment_dir}/{file}.gdt'
        if not os.path.isfile(file_full_path):
            print(f"file not found: {file_full_path}")
            return '   '

        data, _ = Statistics.read_gdt(file_full_path)
        if np.all(data[column_a] == 0) or np.all(data[column_a] == data[column_a][0]) or \
                np.all(data[column_b] == 0) or np.all(data[column_b] == data[column_b][0]):
            return "            "
        else:
            return  [self.get_cross_correlation_result(data, column_a, column_b, 0),
                     self.get_cross_correlation_result(data, column_a, column_b, 1),
                     self.get_cross_correlation_result(data, column_a, column_b, 2)]

    def determine_cross_correlation(self, experiment_dir, file, column_a, column_b):
        file_full_path = self.working_dir + f'/{experiment_dir}/{file}.gdt'
        if not os.path.isfile(file_full_path):
            print(f"file not found: {file_full_path}")
            return [None,None,None]

        data, _ = Statistics.read_gdt(file_full_path)
        if np.all(data[column_a] == 0) or np.all(data[column_a] == data[column_a][0]) or \
                np.all(data[column_b] == 0) or np.all(data[column_b] == data[column_b][0]):
            return [None,None,None]
        else:
            return  [self.get_cross_correlation_result(data, column_a, column_b, 0),
                    self.get_cross_correlation_result(data, column_a, column_b, 1),
                    self.get_cross_correlation_result(data, column_a, column_b, 2)]

    def plot(self, working_dir:str, input_experiments: list, output:str, correlations_files:list=None,
             p_values: list = []):
        if input_experiments:
            experiments = {}
            for args_item in input_experiments:
                for item in args_item.strip().split(" "):
                    if item in self.RENAMES:
                        experiments[item] = self.RENAMES[item][1:] \
                            if self.RENAMES[item].startswith('_') else self.RENAMES[item]
                    else:
                        if ':' in item:
                            item_split = item.split(':')
                            experiments[item_split[0]] = item_split[1][1:] \
                                if item_split[1].startswith('_') else item_split[1]
                        else:
                            experiments[item] = item
            self.axis_y = list(experiments.keys())
            self.titles_y = list(experiments.values())
        if p_values != []:
            self.x = []
            for item1 in p_values:
                for item in item1.strip().split(" "):
                    self.x.append(float(item))
        self.working_dir = working_dir
        self.output, _ = os.path.splitext(os.path.basename(output.lower()))
        output_txt = self.working_dir + '/' + self.output +'.txt'
        output_png = self.working_dir + '/' + self.output +'.png'
        output_file = open(output_txt, "w")
        rows, cols = len(self.axis_y), len(self.axis_x)
        plt.title(self.title_of_output)
        fig, axes = plt.subplots(rows, cols, figsize=(23.4, 16.5))  # a2
        # fig, axes = plt.subplots(rows, cols, figsize=(12, 10))



        for i, item_i in enumerate(self.axis_y):
            if not os.path.isdir(self.working_dir + '/' + item_i):
                print(f"not found {self.working_dir}/{item_i}")
                break
            data, _ = Statistics.read_gdt(self.working_dir + '/' + item_i + '/results.gdt')

            yys = {}
            min_y = np.inf
            max_y = 0
            for j, item_j in enumerate(self.axis_x):
                y = np.log(data[item_j]) if item_j in self.with_log else data[item_j]
                yerr = np.array(y.std()/2) if item_j in self.with_log else data['std_' + item_j] / 2
                yys[item_j] = y

                if (y.max() + yerr.max()) > max_y:
                    max_y = y.max() + yerr.max()
                if (y.min() - yerr.max()) < min_y:
                    min_y = y.min() - yerr.max()
                if len(self.x)!=len(y):
                    print("probably PlotPsi.x differs from values of p in experiments")
                    print(self.x," with size ",len(self.x)," and len(y)=",len(y))
                    sys.exit(0)
                axes[i, j].errorbar(self.x, y, yerr=yerr, fmt='o-', color='black', ecolor='black',
                                    capsize=3, elinewidth=1, markerfacecolor='none', markeredgecolor='black')
                axes[i, j].grid(False)
                axes[i, j].set_facecolor('white')
                if i == rows - 1:
                    axes[i, j].set_xlabel(self.titles_x[j])
                if j == 0:
                    axes[i, j].set_ylabel(self.titles_y[i])
            for j, item_j in enumerate(self.axis_y):
                axes[i, j].set_ylim( min_y, max_y)
            output_file.write(f"-----------{self.titles_y[i].replace('$','')}-----------\n")
            title = "%7s" % ''
            for item_j in self.titles_y:
                title += "%14s" % item_j
            output_file.write(title + '\n')
            for k, value in enumerate(self.x):
                result = "p=%5.3f" % value
                for item_j in self.axis_x:
                    result += "%14.6f" % yys[item_j][k]
                output_file.write(result+'\n')

        if correlations_files:
            for file in correlations_files:
                for correlation in self.correlations:
                    result = f'-----------{file}-----------\n                        '
                    data = [None] * len(self.axis_y)
                    for i, experiment in enumerate(self.axis_y):
                        result += "%15s" % self.titles_y[i]
                        data[i] = self.determine_cross_correlation(experiment, file, correlation[0], correlation[1])

                    for j in range(len(data[0])):
                        result += "\n%10s/%10s t=%d " % (correlation[0][:10],correlation[1][:10],j)
                        for i, experiment in enumerate(self.axis_y):
                            result += "%-10s " % self.format_cross_correlation_result(data[i][j])
                    result += '\n'
                    output_file.write(result)

        plt.savefig(output_png)
        plt.tight_layout()
        output_file.close()
        print("plot: ", output_png )
        print("data: ", output_txt )


def run_interactive():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", action='append', help='List of executions to unify.'
                        ' by default: '+ ' '.join(PlotPsi.axis_y))
    parser.add_argument("--working_dir", default=PlotPsi.working_dir,
                        help="Directory where this executions are located")
    parser.add_argument("--output", default=PlotPsi.output,
                        help=f"File to be generated (.png for plot and .txt for data)")
    parser.add_argument("--correlations", action='append', default=[],
                        help=f"Take from each execution is located, a file to determine correlations (p0200_8 p0200_3)")
    parser.add_argument("--p_values", action='append', default=[],
                        help=f"P values to consider: (0.0001 0.05 0.1 0.15 0.2)")
    args = parser.parse_args()
    plot_psi = PlotPsi()
    plot_psi.plot(working_dir=args.working_dir, input_experiments=args.input, output=args.output,
                  correlations_files=args.correlations, p_values=args.p_values)


if __name__ == "__main__":
    run_interactive()

